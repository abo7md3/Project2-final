// Add a new row or column to each span which shows the average of the statistics for this span function addAveragesToSpans(by_columns) { includeWeb('Table JavaScript Utility Functions'); // Choose appropriate heading and summary let heading_text = 'Add
Average Rows to Tables Containing Spans'; let desc_text = 'Adds an average row next to every span, computed as the average of the statistics in the span'; if (by_columns) { heading_text = heading_text.replace('Rows', 'Columns'); desc_text = desc_text.replace('row',
'column'); } let summary_text = heading_text.charAt(0) + heading_text.slice(1).toLowerCase(); form.setHeading(heading_text); form.setSummary(summary_text); let desc = form.newLabel(desc_text); desc.lineBreakAfter = true; let span_choices = by_columns
? ['Left', 'Right'].map(lab => lab + ' of span') : ['Above', 'Below'].map(lab => lab + ' each span'); let span_position_label = form.newLabel('Position: ') let span_position = form.newComboBox('spanPos', span_choices); span_position.setDefault(span_choices[1]);
let add_span_label = form.newCheckBox('includeSpanLabels', 'Include span label in new ' + (by_columns ? 'column' : 'row') + ' labels'); add_span_label.setDefault(false); let add_labels = add_span_label.getValue(); form.setInputControls([desc, span_position_label,
span_position, add_span_label]); // Don't apply the rule for columns when the table can't have any column spans if (by_columns && table.numberColumns
< 2) { form.ruleNotApplicable( ' table cannot have any column spans') } let spans=b y_columns ? table.columnSpans
    : table.rowSpans;// Get the list of spans. // Work out which spans are lowest in the table. // These are the spans that are tested within. function getLowestLevelSpans(spans) { let lowest_spans=[ ]; let found_indices=[ ]; spans.forEach(function (span)
    { if (span.indices.every(function (x) { return found_indices.indexOf(x)==- 1; })) { found_indices=f ound_indices.concat(span.indices); lowest_spans.push(span); } }); return lowest_spans; } let lowest_spans=g etLowestLevelSpans(spans) lowest_spans=l owest_spans.sort(function
    (a, b) { let indices_a=a .indices; let indices_b=b .indices; let last_a=i ndices_a[indices_a.length - 1]; let last_b=i ndices_b[indices_b.length - 1]; return last_a - last_b; }); let at_after_position=s pan_position.getValue().startsWith(by_columns ?
    'Right' : 'Below'); for (let i=l owest_spans.length - 1; i>= 0;i--) {// Working backwards through the list of spans... let span = lowest_spans[i]; // Get the current span. let span_indices = span.indices; let span_label = 'Average' + (add_labels ? (' of ' + span.label) : ''); // Determine where to insert the
    Average Row/Col, // If the insertion is on the left, the span indices are shifted to accommodate the new row/col. let insert_index; if (at_after_position) { insert_index = span_indices[span_indices.length - 1]; } else { insert_index = span_indices[0]
    > 0 ? span_indices[0] - 1 : null; span_indices = span_indices.map(idx => idx + 1); } // Add a row or column for this span if (by_columns) insertColumnAfterComplete(insert_index, span_label); else insertRowAfterComplete(insert_index, span_label); //
    Determine the new position of the average let average_index = insert_index === null ? 0 : insert_index + 1; // Compute the averages and add them to the table table.statistics.forEach(function (stat) { let values = table.get(stat); if (by_columns)
    { for (let row = 0; row
    < table.numberRows; row++) { if (typeof values[0][0] !='string' ) { let sum=0 ; let count=0 ; for (let j=0 ; j < span_indices.length; j++) { var column=s pan_indices[j]; if (!isNaN(values[row][column])) { sum +=v alues[row][column];
        count++; } } values[row][average_index]=s um / count; } else if (stat=='Column Comparisons' ) values[row][average_index]='-' ; // Set hyphen to indicate that this cell is not being tested. } } else { for (let column=0 ; column < table.numberColumns;
        column++) { if (typeof values[0][0] !='string' ) { let sum=0 ; let count=0 ; for (let j=0 ; j < span_indices.length; j++) { let row=s pan_indices[j]; if (!isNaN(values[row][column])) { sum +=v alues[row][column]; count++; } } values[average_index][column]=s
        um / count; } else if (stat=='Column Comparisons' ) values[average_index][column]='-' ; // Set hyphen to indicate that this cell is not being tested. } } table.set(stat, values); }); } }